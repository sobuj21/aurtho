<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Aurtho - A futuristic site under construction. Stay tuned." />
    <meta name="keywords" content="Aurtho, futuristic, modern, forest, tech, under construction" />
    <meta name="author" content="Aurtho" />
    <title>Aurtho | Under Construction</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Rajdhani:wght@400;700&display=swap" rel="stylesheet">
    <!-- Include Three.js library for 3D effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Global Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Prevent scrollbars due to fixed canvas */
        html, body {
            overflow: hidden;
            /* Ensure body has a default background for the final fade to black */
            background-color: black; /* Explicitly black */
        }

        /* Body Styling */
        body {
            font-family: 'Rajdhani', sans-serif;
            background: transparent; /* No background on body, handled by canvas */
            height: 100vh; /* Full viewport height */
            color: #fff; /* White text color for all content */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Distribute space between header, main, and footer */
            position: relative; /* Needed for z-index context for child elements */
            z-index: 0; /* Base z-index for body content */
            transform-style: preserve-3d; /* For better 3D rendering quality on some browsers */
        }

        /* Three.js Canvas Styling - fixed to cover the entire viewport */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place behind all other content */
            /* IMPORTANT: Removed background-image here to prevent flash on reload */
            background-color: black; /* Ensure it's black by default */
            transition: opacity 0.5s ease-out; /* For fading out the canvas */
        }

        /* Header Styling */
        header {
            text-align: center;
            padding: 2rem;
            background: transparent; /* No background, let 3D canvas show through */
            backdrop-filter: none;
            position: relative; /* Ensure it's above the canvas */
            z-index: 1;
        }

        /* Logo Link Styling - styled as a glowing, transparent button */
        .logo-link {
            text-decoration: none; /* Remove underline */
            color: inherit; /* Inherit color from parent to apply gradient */
            cursor: pointer; /* Indicate it's clickable */
            display: inline-block; /* Allows padding/margin and button styling */
            padding: 0.5rem 1.5rem; /* Padding for visual space */
            border: none; /* No visible border */
            border-radius: 30px; /* "Little circular" effect */
            background-color: transparent; /* Fully transparent background */
            /* Add a subtle glowing box shadow */
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.4), inset 0 0 10px rgba(0, 240, 255, 0.2);
            transition: all 0.3s ease; /* Smooth transition for hover effects */
        }

        .logo-link:hover {
            box-shadow: 0 0 25px rgba(0, 240, 255, 0.8), inset 0 0 15px rgba(0, 240, 255, 0.4); /* Brighter glow on hover */
            transform: translateY(-3px); /* Slight lift effect on hover */
        }

        /* Logo Text Styling */
        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            /* Gradient text effect */
            background: linear-gradient(to right, #00f0ff, #ff007c, #00ff8c, #1e90ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 4s ease-in-out infinite; /* Pulsating glow animation */
            /* Add text shadow for a more pronounced 3D/glowing effect */
            text-shadow: 0 0 8px rgba(0, 240, 255, 0.6), 0 0 15px rgba(255, 0, 124, 0.4);
        }

        /* Glow Animation for Logo */
        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 4px #00fff2); } /* Initial and final glow */
            50% { filter: drop-shadow(0 0 10px #ff5cf5); } /* Stronger glow in the middle */
        }

        /* Main Content Styling */
        main {
            text-align: center;
            margin: auto; /* Center the main content vertically and horizontally */
            padding: 2rem;
            position: relative; /* Ensure it's above the canvas */
            z-index: 1;
        }

        /* Message Text Styling */
        .message {
            font-size: 2rem;
            font-family: 'Orbitron', sans-serif; /* Futuristic font */
            /* Gradient text effect for the message */
            background: linear-gradient(to right, #ff6ec4, #7873f5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 2rem;
            /* Add text shadow for a more pronounced 3D/glowing effect */
            text-shadow: 0 0 8px rgba(255, 110, 196, 0.6), 0 0 15px rgba(120, 115, 245, 0.4);
        }

        /* Footer Styling */
        footer {
            text-align: center;
            padding: 2rem;
            background: transparent; /* No background, let 3D canvas show through */
            backdrop-filter: none;
            font-size: 1rem;
            position: relative; /* Ensure it's above the canvas */
            z-index: 1;
        }

        /* Contact Info Container */
        .contact-info {
            display: flex;
            justify-content: center;
            gap: 2rem; /* Space between contact links */
            flex-wrap: wrap; /* Allow links to wrap on smaller screens */
        }

        /* Contact Link Styling - now glowing, transparent button-like elements */
        .contact-info a {
            color: #00fff2; /* Cyan-like color for links */
            text-decoration: none;
            padding: 0.75rem 1.5rem; /* Padding for visual space */
            border: none; /* No visible border */
            border-radius: 30px; /* "Little circular" effect */
            background-color: transparent; /* Fully transparent background */
            /* Add a strong glowing box shadow */
            box-shadow: 0 0 15px rgba(0, 255, 242, 0.5), inset 0 0 10px rgba(0, 255, 242, 0.3);
            transition: all 0.3s ease; /* Smooth transition for hover effects */
            /* Add text shadow for glowing text */
            text-shadow: 0 0 5px #00fff2, 0 0 10px #00fff2;
        }

        /* Contact Link Hover Effect */
        .contact-info a:hover {
            color: #ff5cf5; /* Pink-like color on hover */
            box-shadow: 0 0 25px rgba(255, 92, 245, 0.8), inset 0 0 15px rgba(255, 92, 245, 0.4); /* Brighter glow on hover */
            transform: translateY(-3px); /* Slight lift effect on hover */
            text-shadow: 0 0 8px #ff5cf5, 0 0 15px #ff5cf5; /* Brighter text glow on hover */
        }

        /* Responsive Adjustments for Smaller Screens */
        @media (max-width: 768px) {
            .logo {
                font-size: 2.2rem; /* Smaller logo on mobile */
            }
            .logo-link {
                padding: 0.4rem 1rem;
            }
            .message {
                font-size: 1.5rem; /* Smaller message on mobile */
            }
            .contact-info a {
                padding: 0.6rem 1.2rem;
            }
        }

        /* Class for elements to be animated into the black hole */
        .black-hole-animating {
            transition: transform 3.5s ease-in, opacity 3.5s ease-in; /* Longer, accelerating transition */
            will-change: transform, opacity;
        }
    </style>
</head>

<body>
    <!-- Canvas for the 3D background. This will render the Three.js scene. -->
    <canvas id="three-canvas"></canvas>

    <header>
        <!-- The logo is wrapped in an anchor tag to make it clickable -->
        <a href="/" class="logo-link" aria-label="Reload page">
            <div class="logo">Aurtho</div>
        </a>
    </header>

    <main>
        <div class="message">Website is under construction,<br />Please visit again later.</div>
    </main>

    <footer>
        <div class="contact-info">
            <a href="https://wa.me/17162268360" target="_blank" rel="noopener noreferrer">WhatsApp</a>
            <a href="https://www.facebook.com/sobujis" target="_blank" rel="noopener noreferrer">Facebook</a>
        </div>
        <div style="margin-top: 1rem; opacity: 0.6;">&copy; 2025 Aurtho.com. All rights reserved.</div>
    </footer>

    <script>
        // Three.js variables
        let scene, camera, renderer, particles;
        const canvas = document.getElementById('three-canvas');

        // Animation state variables
        let isBlackHoleActive = false;
        let blackHoleStartTime = 0;

        const blackHoleDuration = 3500; // 3.5 seconds for black hole animation
        const elementStaggerDelay = 70; // Delay in milliseconds between each element's animation start

        // References to HTML elements to animate
        let animatingElements = [];
        // Store original positions and styles for accurate restoration
        let originalElementStates = new Map();

        // Particle animation state
        let particleState = 'normal'; // 'normal', 'blackHolePull'

        /**
         * Initializes the Three.js scene, camera, renderer, and particles.
         * Also prepares HTML elements for animation by identifying main components.
         */
        function init() {
            // Create a new Three.js scene
            scene = new THREE.Scene();

            // Setup the perspective camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5; // Position the camera slightly back

            // Initialize the WebGL renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to match window
            renderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens
            renderer.setClearColor(0x000000); // Ensure the canvas background is black

            // Create a particle system for the abstract 3D background
            const particleCount = 5000; // Increased particle count for more density
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3); // x, y, z for each particle
            const colors = new Float32Array(particleCount * 3); // r, g, b for each particle
            const velocities = new Float32Array(particleCount * 3); // Store velocities for dynamic movement

            // Define colors for the particle gradient
            const color1 = new THREE.Color(0x00f0ff); // Cyan
            const color2 = new THREE.Color(0xff007c); // Pink
            const color3 = new THREE.Color(0x00ff8c); // Green

            // Populate particle positions and colors
            for (let i = 0; i < particleCount; i++) {
                // Randomly position particles within a cube space
                positions[i * 3] = (Math.random() - 0.5) * 20; // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20; // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20; // z

                // Initialize velocities to zero
                velocities[i * 3] = 0;
                velocities[i * 3 + 1] = 0;
                velocities[i * 3 + 2] = 0;

                // Assign a random color from the defined gradient colors
                const mixedColor = new THREE.Color();
                const r = Math.random();
                if (r < 0.33) mixedColor.copy(color1);
                else if (r < 0.66) mixedColor.copy(color2);
                else mixedColor.copy(color3);

                colors[i * 3] = mixedColor.r;
                colors[i * 3 + 1] = mixedColor.g;
                colors[i * 3 + 2] = mixedColor.b;
            }

            // Set attributes for the geometry
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); // Add velocity attribute

            // Create the material for the particles
            const material = new THREE.PointsMaterial({
                size: 0.05, // Size of each particle
                vertexColors: true, // Use colors defined in the geometry
                transparent: true, // Allow transparency
                blending: THREE.AdditiveBlending, // For glowing effect
                sizeAttenuation: true // Particles further away appear smaller
            });

            // Create the particle system and add it to the scene
            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Add ambient light to the scene
            const ambientLight = new THREE.AmbientLight(0x404040); // Soft white light
            scene.add(ambientLight);

            // Add a point light for additional illumination (optional for particles)
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Event listener for window resizing to keep the canvas responsive
            window.addEventListener('resize', onWindowResize, false);

            // Identify main HTML elements to animate
            const logoLink = document.querySelector('.logo-link');
            const messageDiv = document.querySelector('.message');
            const contactLinks = Array.from(document.querySelectorAll('footer .contact-info a'));
            const copyrightDiv = document.querySelector('footer div:last-child');

            // Add these main elements to the animatingElements array
            if (logoLink) {
                animatingElements.push(logoLink);
            }
            if (messageDiv) {
                animatingElements.push(messageDiv);
            }
            // Add each contact link directly (these are the "circles")
            animatingElements = animatingElements.concat(contactLinks);
            if (copyrightDiv) {
                animatingElements.push(copyrightDiv);
            }
            // Elements are still in their normal document flow at this point.
            // Their positions and styles will be captured just before animation starts.
        }

        /**
         * Handles window resizing, updating camera aspect ratio and renderer size.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Update camera's projection matrix
            renderer.setSize(window.innerWidth, window.innerHeight); // Resize renderer
        }

        /**
         * Starts the black hole animation for HTML elements with a staggered effect.
         * This function is called ONLY when the "Aurtho" button is clicked.
         */
        function startBlackHoleAnimation() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;

            let currentDelay = 0;

            // Capture current positions and styles, then apply fixed positioning
            animatingElements.forEach(el => {
                const rect = el.getBoundingClientRect();
                const computedStyle = window.getComputedStyle(el);

                // Store original state for restoration
                originalElementStates.set(el, {
                    rect: { x: rect.left, y: rect.top, width: rect.width, height: rect.height },
                    position: el.style.position || computedStyle.position, // Use inline style if present, else computed
                    top: el.style.top || computedStyle.top,
                    left: el.style.left || computedStyle.left,
                    width: el.style.width || computedStyle.width,
                    height: el.style.height || computedStyle.height,
                    transform: el.style.transform || computedStyle.transform,
                    opacity: el.style.opacity || computedStyle.opacity,
                    display: el.style.display || computedStyle.display,
                    margin: el.style.margin || computedStyle.margin,
                    zIndex: el.style.zIndex || computedStyle.zIndex
                });

                // Apply fixed positioning and initial transform to maintain current visual position
                el.style.position = 'fixed';
                el.style.top = `${rect.top}px`;
                el.style.left = `${rect.left}px`;
                el.style.width = `${rect.width}px`;
                el.style.height = `${rect.height}px`;
                el.style.margin = '0'; // Remove margins to prevent layout shifts
                el.style.zIndex = '10'; // Ensure it's above the canvas
            });

            // Now, trigger the animation for each element with a delay
            animatingElements.forEach((el, index) => {
                setTimeout(() => {
                    el.classList.add('black-hole-animating'); // Add transition class

                    const originalRect = originalElementStates.get(el).rect;
                    if (!originalRect) return; // Safety check

                    // Calculate the center of the element's original fixed position
                    const elCenterX = originalRect.x + originalRect.width / 2;
                    const elCenterY = originalRect.y + originalRect.height / 2;

                    // Calculate translation needed to move its center to the black hole center
                    const translateX = centerX - elCenterX;
                    const translateY = centerY - elCenterY;

                    // Apply the transform to move to center, scale to 0, and rotate
                    el.style.transform = `translate(${translateX}px, ${translateY}px) scale(0) rotate(720deg)`;
                    el.style.opacity = '0';
                }, currentDelay);
                currentDelay += elementStaggerDelay; // Increment delay for the next element
            });

            // After all elements have disappeared, fade to black and reload
            setTimeout(() => {
                // Hide all HTML elements immediately
                animatingElements.forEach(el => {
                    el.style.display = 'none';
                    el.classList.remove('black-hole-animating'); // Remove animation class
                });

                // Fade out the Three.js canvas
                canvas.style.opacity = '0';

                // Ensure body is black
                document.body.style.backgroundColor = 'black';

                // Finally, reload the page after the canvas has faded out
                setTimeout(() => {
                    window.location.reload();
                }, 500); // Wait for canvas fade out (0.5s)
            }, currentDelay + blackHoleDuration + 500); // Add a buffer after last element finishes disappearing
        }

        /**
         * Animation loop for Three.js.
         * This function is called repeatedly to update the scene.
         * @param {DOMHighResTimeStamp} time - The current time provided by requestAnimationFrame.
         */
        function animate(time) {
            requestAnimationFrame(animate); // Request the next animation frame

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array; // Get velocities array
            const originalParticleSize = 0.05;

            if (particleState === 'normal') {
                // Normal particle rotation
                particles.rotation.x += 0.0005;
                particles.rotation.y += 0.001;
                particles.material.opacity = 1;
                particles.material.size = originalParticleSize;
            } else if (particleState === 'blackHolePull') {
                const elapsed = time - blackHoleStartTime;
                const progress = Math.min(elapsed / blackHoleDuration, 1);

                const blackHoleCenter = new THREE.Vector3(0, 0, 0); // Center of the black hole in 3D space

                for (let i = 0; i < particles.geometry.attributes.position.count; i++) {
                    const x = positions[i * 3];
                    const y = positions[i * 3 + 1];
                    const z = positions[i * 3 + 2];

                    const particleVec = new THREE.Vector3(x, y, z);
                    const direction = blackHoleCenter.clone().sub(particleVec); // Vector from particle to center
                    const distance = direction.length();

                    // Increased pull strength and added a slight swirl effect
                    const pullStrength = 0.02 + (1 - distance / 10) * 0.1 * progress; // Stronger pull
                    direction.normalize().multiplyScalar(pullStrength);

                    // Add a slight random component to velocities for more chaotic movement
                    velocities[i * 3] += direction.x + (Math.random() - 0.5) * 0.001;
                    velocities[i * 3 + 1] += direction.y + (Math.random() - 0.5) * 0.001;
                    velocities[i * 3 + 2] += direction.z + (Math.random() - 0.5) * 0.001;

                    // Apply velocities to positions
                    positions[i * 3] += velocities[i * 3];
                    positions[i * 3 + 1] += velocities[i * 3 + 1];
                    positions[i * 3 + 2] += velocities[i * 3 + 2];

                    const fadeDistance = 2.0; // Increased fade distance
                    if (distance < fadeDistance) {
                        const fadeProgress = 1 - (distance / fadeDistance);
                        particles.material.opacity = Math.max(0, 1 - fadeProgress * 3); // Faster fade
                        particles.material.size = Math.max(0.001, originalParticleSize * (1 - fadeProgress * 1.5)); // Faster shrink
                    } else {
                        particles.material.opacity = 1;
                        particles.material.size = originalParticleSize;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.geometry.attributes.velocity.needsUpdate = true; // Update velocities attribute
                particles.material.needsUpdate = true;

                // If black hole animation is nearly complete, fade out particles completely
                if (progress > 0.95) {
                    particles.material.opacity = Math.max(0, particles.material.opacity - 0.05);
                }
            }

            renderer.render(scene, camera); // Render the scene
        }

        // Initialize Three.js and set up event listeners when the window loads
        window.onload = function () {
            init(); // Setup the 3D environment and prepare HTML elements (identify main components)
            animate(0); // Start the animation loop (pass initial time 0)

            // Add click event listener to the logo for the black hole effect
            const logoLink = document.querySelector('.logo-link');
            if (logoLink) {
                logoLink.addEventListener('click', function(event) {
                    event.preventDefault(); // Prevent default link behavior (page reload)

                    if (!isBlackHoleActive) { // Only trigger if no animation is active
                        isBlackHoleActive = true;
                        particleState = 'blackHolePull'; // Set particle state for pull
                        blackHoleStartTime = performance.now(); // Record start time of animation

                        // Start animating HTML elements with staggered delays
                        startBlackHoleAnimation();
                    }
                });
            }
        };
    </script>
</body>

</html>
